'''
로봇청소기 + 방의 상태 = 청소하는 영역의 개수를 구하는 프로그램 작성
방 = NxM 크기의 직사각형 = 각각의 칸은 벽 또는 빈칸
청소기는 바라보는 방향 = 동서남북
방의 각 칸 = (r,c)
가장 북쪽 줄의 가장 서쪽 칸의 좌표가 (0,0) 남동 (N-1,M-1)
처음 빈칸은 모두 청소되지 않은 상태

<로봇 청소기 작동 원리>
1 현재 칸이 청소되지 않은 경우, 청소한다.

2 현재 칸의 주변 4칸 중 청소되지 않은 빈칸이 없는 경우
    1 바라보는 방향을 유지한 채로 / 한 칸 후진할 수 있다면 / 한칸 후진하고, 1번으로
    2 바라보는 방향의 뒤쪽 칸이 벽이라 / 후진할 수 없다면 > 작동을 멈춘다

3 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 있는 경우
    1 반시계 방향으로 90 회전한다
    2 바라보는 방향을 기준으로 > 앞쪽 칸이 청소되지 않은 빈칸인 경우 / 한 칸 전진
    3 1번으로 돌아간다
'''

def solve(ci, cj, dr):
    cnt = 0 #청소한 공간 수

    while True :
        #현재 청소기가 더 이상 움직이지 못하면 종료
        # [1] 현재 위치 청소
        arr[ci][cj] = 2
        cnt += 1

        # [2] 왼쪽 방향으로 순서대로 탐색해서 미청소 영역이 있는 경우 이동
        # 없으면 후진한다
        flag = 1
        while flag == 1:        # 계속 탐색해야 함
            # 왼쪽부터 네 방향 중 미청소 영역이 있는 경우 (3)
            for nd in ((dr+3)%4,(dr+2)%4,(dr+1)%4,dr): #(3-1)
                ni, nj = ci + di[nd], cj + dj[nd]
                if arr[ni][nj] == 0: #미청소 영역
                    ci, cj, dr = ni, nj, nd            #(3-2)
                    flag = 0        #계속 탐색할 필요 없음
                    break
            else: #네 방향 모두 미청소 영역이 없는 경우 (2)
                bi, bj = ci - di[dr], cj - di[dr] #후진할 위치 계산
                if arr[bi][bj] == 1: #벽 이다 (2-2)
                    return cnt
                else:
                    ci, cj = bi, bj #벽이 아니라면 그대로 후진 진행 (2-1)
                    # break 하지 않는 이유는 미청소 영역이 없기에, 청소하지 않기 때문 > 계속 탐색
    return -1

# dr 북 동 남 서
di = [-1, 0, 1, 0]
dj = [0, 1, 0, -1]

N, M = map(int, input().split())
si, sj, dr = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]

ans = solve(si, sj, dr)
print(ans)
